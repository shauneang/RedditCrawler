import fs from "fs";
import path from "path";
import PDFDocument from "pdfkit";
import { fetchTopMemes } from "../services/redditServices";
import { MemeDataType } from "../type/redditTypes";

/**
 * Generate a valid PDF report and return its file path
 */
export const generateReport = async (): Promise<string> => {
    return new Promise((resolve, reject) => {
        try {
            const filePath = path.join(__dirname, "../../top_memes_report.pdf");
            const doc = new PDFDocument(); // Create a new PDF document
            const stream = fs.createWriteStream(filePath);

            doc.pipe(stream); // Pipe to a file
            doc.fontSize(20).text("üìä Report Title", { align: "center" });
            doc.moveDown();
            doc.fontSize(14).text("This is a test report generated by the Telegram bot.");
            doc.moveDown();
            doc.text("Generated on: " + new Date().toLocaleString());

            doc.end(); // Finalize the PDF

            stream.on("finish", () => resolve(filePath)); // Resolve when finished
            stream.on("error", (err) => reject(err));
        } catch (error) {
            reject(error);
        }
    });
};

/**
 * Scrape top memes and save them as a JSON file
 * @returns {Promise<string>} - The file path of the saved JSON file
 */
export const scrapeData = async (): Promise<string> => {
    try {
        const memes: MemeDataType[] = await fetchTopMemes(20); // Fetch memes

        const filePath = path.join(__dirname, "../../top_memes_data.json"); // Set file path

        // Convert memes to JSON and save to a file
        fs.writeFileSync(filePath, JSON.stringify(memes, null, 2), "utf-8");

        console.log(`‚úÖ Memes saved to ${filePath}`);
        return filePath; // Return file path for Telegram bot to send
    } catch (error) {
        console.error("‚ùå Error saving memes to JSON:", error);
        throw new Error("Failed to scrape and save memes.");
    }
};